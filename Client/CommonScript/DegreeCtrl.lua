Require("CommonScript/Recharge/Recharge.lua")
DegreeCtrl.tbSetting = {
  Revenge = {
    {5, 1},
    {5, 2},
    "Day",
    "4:00",
    10,
    "复仇"
  },
  Catch = {
    {5, 6},
    {5, 7},
    "Day",
    "4:00",
    5,
    "免费抓捕次数"
  },
  CatchBuy = {
    {5, 8},
    {5, 9},
    "Day",
    "4:00",
    20,
    "购买抓捕次数"
  },
  RankBattle = {
    {7, 1},
    {7, 2},
    "",
    "",
    10,
    "武神殿挑战次数"
  },
  RankBattleBuy = {
    {7, 3},
    {7, 4},
    "Day",
    "4:00",
    0,
    "武神殿购买次数"
  },
  Debris = {
    {10, 3},
    {10, 4},
    "Day",
    "10:00",
    10,
    "碎片抢夺次数"
  },
  DebrisBuy = {
    {10, 5},
    {10, 6},
    "Day",
    "10:00",
    0,
    "碎片抢夺购买次数"
  },
  RandomFuben = {
    {9, 1},
    {9, 2},
    "Day",
    "4:00",
    2,
    "随机副本次数"
  },
  Battle = {
    {11, 1},
    {11, 2},
    "Day",
    "4:00",
    1,
    "战场次数"
  },
  BattleAdd = {
    {11, 3},
    {11, 4},
    "Day",
    "4:00",
    1,
    "战场增加次数"
  },
  DungeonFubenInvited = {
    {12, 1},
    {12, 2},
    "Day",
    "4:00",
    2,
    "地宫被邀请次数"
  },
  MapExplore = {
    {12, 3},
    {12, 4},
    "Day",
    "4:00",
    10,
    "地图探索次数"
  },
  MapExploreBuy = {
    {12, 5},
    {12, 6},
    "Day",
    "4:00",
    0,
    "地图探索次数购买"
  },
  PunishTask = {
    {16, 1},
    {16, 2},
    "Day",
    "4:00",
    5,
    "惩恶的次数"
  },
  PunishTaskBuy = {
    {17, 1},
    {17, 2},
    "Day",
    "4:00",
    0,
    "购买惩恶次数"
  },
  HeroChallenge = {
    {43, 6},
    {43, 7},
    "Day",
    "4:00",
    2,
    "英雄会挑战次数"
  },
  Pray = {
    {14, 7},
    {14, 8},
    "Day",
    "4:00",
    1,
    "祈福次数"
  },
  PrayBuy = {
    {14, 9},
    {14, 10},
    "Day",
    "4:00",
    4,
    "购买祈福次数"
  },
  ChuangGong = {
    {23, 1},
    {23, 2},
    "Day",
    "4:00",
    2,
    "接受传功次数"
  },
  ChuangGongBuy = {
    {23, 3},
    {23, 4},
    "Day",
    "4:00",
    0,
    "接受传功次数"
  },
  ChuangGongSend = {
    {23, 5},
    {23, 6},
    "Day",
    "4:00",
    1,
    "发起传功次数"
  },
  QunYingHuiDay = {
    {24, 1},
    {24, 2},
    "Day",
    "0:00",
    6,
    "群英会比赛日次数"
  },
  TeamFuben = {
    {13, 1},
    {13, 2},
    "Day",
    "4:00",
    2,
    "组队副本次数"
  },
  AdventureFuben = {
    {31, 1},
    {31, 2},
    "Day",
    "4:00",
    2,
    "奇遇秘境次数"
  },
  DonationCount = {
    {32, 1},
    {32, 2},
    "Day",
    "4:00",
    0,
    "家族捐献次数"
  },
  KinNestDay = {
    {35, 1},
    {35, 2},
    "Day",
    "0:00",
    4,
    "家族巢穴奖励"
  },
  ActivityQuestion = {
    {28, 15},
    {28, 16},
    "Day",
    "4:00",
    1,
    "每日答题次数"
  },
  CommerceTask = {
    {33, 1},
    {33, 2},
    "Day",
    "4:00",
    1,
    "商会任务次数"
  },
  KinRobReward = {
    {36, 1},
    {36, 2},
    "Day",
    "00:00",
    4,
    "家族盗贼奖励"
  },
  KinTask = {
    {40, 1},
    {40, 2},
    "Day",
    "4:00",
    10,
    "家族任务"
  },
  XinDeBook = {
    {114, 1},
    {114, 2},
    "Day",
    "00:00",
    10,
    "心得书的次数"
  },
  WhiteTigerFuben = {
    {46, 1},
    {46, 2},
    "Day",
    "4:00",
    1,
    "白虎堂次数"
  },
  PublicChatCount = {
    {50, 1},
    {50, 2},
    "Day",
    "4:00",
    0,
    "世界聊天次数"
  },
  CrossChatCount = {
    {50, 4},
    {50, 5},
    "Day",
    "4:00",
    0,
    "主播聊天次数"
  },
  DuoBaoZeiCount = {
    {81, 1},
    {81, 2},
    "Day",
    "4:00",
    50,
    "夺宝贼每天可击杀有奖励数量"
  },
  ChuangGongAdd = {
    {83, 1},
    {83, 2},
    "Day",
    "4:00",
    1,
    "增加传功次数道具的使用个数"
  },
  Idioms = {
    {119, 1},
    {119, 2},
    "Day",
    "4:00",
    2,
    "成语接龙副本次数"
  },
  DefendFuben = {
    {120, 1},
    {120, 2},
    "Day",
    "4:00",
    1,
    "守卫名侠副本次数"
  },
  DaXueZhangAdd = {
    {122, 3},
    {122, 4},
    "Day",
    "4:00",
    1,
    "打雪仗的增加次数"
  },
  InDifferBattle = {
    {118, 1},
    {118, 2},
    "Day",
    "4:00",
    1,
    "心魔幻境次数"
  },
  IndifferAdd = {
    {118, 4},
    {118, 5},
    "Day",
    "4:00",
    1,
    "心魔增加次数"
  },
  SnowmanActAward = {
    {123, 1},
    {123, 2},
    "Day",
    "4:00",
    1,
    "堆雪人活动领取礼盒次数"
  },
  Muse = {
    {131, 1},
    {131, 2},
    "Day",
    "4:00",
    1,
    "冥想次数"
  },
  PlantCure = {
    {133, 1},
    {133, 2},
    "Day",
    "4:00",
    1,
    "植物养护次数"
  },
  PlantHelpCure = {
    {133, 3},
    {133, 4},
    "Day",
    "4:00",
    10,
    "协助养护次数"
  }
}
local tbSetting = DegreeCtrl.tbSetting
DegreeCtrl.tbSetting = tbSetting
DegreeCtrl.tbBuyCountSetting = {
  Catch = {
    "CatchBuy",
    "Gold",
    20
  },
  Debris = {
    "DebrisBuy",
    "Gold",
    {
      {5, 5},
      {10, 10},
      {15, 20},
      {20, 30},
      {25, 45},
      {30, 60},
      {35, 80},
      {40, 100}
    }
  },
  MapExplore = {
    "MapExploreBuy",
    "Gold",
    {
      {5, 4},
      {10, 12},
      {15, 24},
      {20, 40}
    }
  },
  PunishTask = {
    "PunishTaskBuy",
    "Gold",
    {
      {5, 3},
      {10, 9},
      {15, 18},
      {20, 30}
    }
  },
  ChuangGong = {
    "ChuangGongBuy",
    "Gold",
    {
      {1, 80},
      {2, 120},
      {3, 160},
      {4, 200}
    }
  },
  MoneyTreeFree = {
    "MoneyTreeExt",
    "Gold",
    {
      {10, 10},
      {20, 15},
      {200, 20}
    }
  },
  RankBattle = {
    "RankBattleBuy",
    "Gold",
    {
      {5, 5},
      {10, 15},
      {15, 30},
      {20, 50}
    }
  }
}
local tbBuyCountSetting = DegreeCtrl.tbBuyCountSetting
DegreeCtrl.tbAddSetting = {
  RankBattle = {14400}
}
local tbAddSetting = DegreeCtrl.tbAddSetting
function DegreeCtrl:Init()
  local tbCols = {}
  local szColType = "s"
  for i = 0, Recharge.nMaxVip do
    table.insert(tbCols, tostring(i))
    szColType = szColType .. "d"
  end
  self.tbVipExSetting = LoadTabFile("Setting/DegreeCtrl/VipDegree.tab", szColType, "Degree", {
    "Degree",
    unpack(tbCols)
  })
end
DegreeCtrl:Init()
function DegreeCtrl:GetDegreeDesc(szName)
  if tbSetting[szName] then
    return tbSetting[szName][6]
  end
end
function DegreeCtrl:_GetAdditional(pPlayer, szName)
  if szName == "ChuangGong" then
    local tbMember = Kin:GetMemberData(pPlayer.dwID)
    if tbMember and tbMember.nCareer == Kin.Def.Career_New then
      return 2
    end
  end
  return 0
end
function DegreeCtrl:GetMaxDegree(szName, pPlayer)
  local nValue = 0
  if tbSetting[szName] then
    if not self.tbVipExSetting[szName] then
      nValue = tbSetting[szName][5]
    else
      if not pPlayer then
        Log(debug.traceback(), szName)
        return
      end
      local nVipLevel = pPlayer.GetVipLevel()
      nValue = tbSetting[szName][5] + self.tbVipExSetting[szName][tostring(nVipLevel)]
    end
  end
  nValue = nValue + self:_GetAdditional(pPlayer, szName)
  return nValue
end
function DegreeCtrl:GetNextVipDegree(szName, pPlayer)
  local tbInfo = self.tbVipExSetting[szName]
  if not tbInfo then
    return
  end
  local nCurVipLevel = pPlayer.GetVipLevel()
  local nCurDegree = tbInfo[tostring(nCurVipLevel)]
  for i = nCurVipLevel + 1, Recharge.nMaxVip do
    local nDegree = tbInfo[tostring(i)]
    if nCurDegree < nDegree then
      return i
    end
  end
end
function DegreeCtrl:GetDegreeSecond(nDataTime, tbUnCountTime)
  local nUnCountBegin, nUnCountEnd = 0, 0
  if tbUnCountTime then
    nUnCountBegin, nUnCountEnd = unpack(tbUnCountTime)
  end
  local nSecondPerDay = 86400 - nUnCountEnd + nUnCountBegin
  local nLocalDay = Lib:GetLocalDay(nDataTime)
  local nCurDaySecond = Lib:GetLocalDayTime(nDataTime) % 86400
  if nUnCountBegin < nCurDaySecond and nUnCountEnd > nCurDaySecond then
    nCurDaySecond = nUnCountBegin
  elseif nUnCountBegin < nCurDaySecond then
    nCurDaySecond = nCurDaySecond + nUnCountBegin - nUnCountEnd
  end
  return nLocalDay * nSecondPerDay + nCurDaySecond
end
function DegreeCtrl:GetTimeByDegreeSecond(nDegreeSecond, tbUnCountTime)
  local nUnCountBegin, nUnCountEnd = 0, 0
  if tbUnCountTime then
    nUnCountBegin, nUnCountEnd = unpack(tbUnCountTime)
  end
  local nSecondPerDay = 86400 - nUnCountEnd + nUnCountBegin
  local nCurDaySecond = nDegreeSecond % nSecondPerDay
  if nUnCountBegin <= nCurDaySecond then
    nCurDaySecond = nCurDaySecond + nUnCountEnd - nUnCountBegin
  end
  return math.floor(nDegreeSecond / nSecondPerDay) * 24 * 3600 + nCurDaySecond - Lib:GetGMTSec()
end
function DegreeCtrl:GetNextAddTime(pPlayer, szName)
  local nDegree, nLastAddTime = self:GetDegree(pPlayer, szName)
  if nLastAddTime and tbAddSetting[szName] and nDegree < self:GetMaxDegree(szName, pPlayer) then
    local nAddCDTime, tbUnCountTime = unpack(tbAddSetting[szName])
    local nDegreeSecond = self:GetDegreeSecond(nLastAddTime, tbUnCountTime)
    nDegreeSecond = nDegreeSecond + nAddCDTime
    return self:GetTimeByDegreeSecond(nDegreeSecond, tbUnCountTime)
  end
end
function DegreeCtrl:GetUpdateTime(pPlayer, szName)
  local tbInfo = tbSetting[szName]
  if tbInfo then
    local nTimeGroup, nTimeId = unpack(tbInfo[2])
    return pPlayer.GetUserValue(nTimeGroup, nTimeId)
  end
end
function DegreeCtrl:GetDegree(pPlayer, szName)
  if tbAddSetting[szName] and tbSetting[szName] then
    local tbInfo = tbSetting[szName]
    local nAddCDTime, tbUnCountTime = unpack(tbAddSetting[szName])
    local nGroup, nId = unpack(tbInfo[1])
    local nTimeGroup, nTimeId = unpack(tbInfo[2])
    local nMaxDegree = self:GetMaxDegree(szName, pPlayer)
    local nLastTime = pPlayer.GetUserValue(nTimeGroup, nTimeId)
    local nCurDegree = nMaxDegree - pPlayer.GetUserValue(nGroup, nId)
    if nMaxDegree <= nCurDegree then
      return nCurDegree
    end
    local nCurTime = GetTime()
    local nLastSecond = self:GetDegreeSecond(nLastTime, tbUnCountTime)
    local nCurSecond = self:GetDegreeSecond(nCurTime, tbUnCountTime)
    local nAddCount = math.floor((nCurSecond - nLastSecond) / nAddCDTime)
    local nLastAddTime = self:GetTimeByDegreeSecond(nCurSecond - (nCurSecond - nLastSecond) % nAddCDTime, tbUnCountTime)
    return math.min(nMaxDegree, nCurDegree + nAddCount), nLastAddTime
  elseif tbSetting[szName] then
    local tbInfo = tbSetting[szName]
    local nGroup, nId = unpack(tbInfo[1])
    local nTimeGroup, nTimeId = unpack(tbInfo[2])
    local nMaxDegree = self:GetMaxDegree(szName, pPlayer)
    local nLastTime = pPlayer.GetUserValue(nTimeGroup, nTimeId)
    if not nLastTime or nLastTime == 0 then
      return nMaxDegree
    end
    local szFunction = "GetLocal" .. tbInfo[3]
    local nCurTime = GetTime()
    local nClock = tbInfo[4]
    if nClock then
      local nParseTodayTime = Lib:ParseTodayTime(nClock)
      nCurTime = nCurTime - nParseTodayTime
      nLastTime = nLastTime - nParseTodayTime
    end
    local nCurTimeBlock = Lib[szFunction](Lib, nCurTime)
    local nLastTimeBlock = Lib[szFunction](Lib, nLastTime)
    local nCostedDegree = pPlayer.GetUserValue(nGroup, nId)
    if nCurTimeBlock == nLastTimeBlock then
      return math.max(nMaxDegree - nCostedDegree, 0)
    else
      return math.max(nMaxDegree, nMaxDegree - nCostedDegree)
    end
  end
end
function DegreeCtrl:SetDegree(pPlayer, szName, nDegree, nTime)
  local tbInfo = tbSetting[szName]
  if not tbInfo then
    return false
  end
  local nGroup, nId = unpack(tbInfo[1])
  local nTimeGroup, nTimeId = unpack(tbInfo[2])
  pPlayer.SetUserValue(nGroup, nId, nDegree)
  pPlayer.SetUserValue(nTimeGroup, nTimeId, nTime)
  Log(string.format("DegreeCtrl:SetDegree pPlayer:%d, szName:%s, nDegree:%d, nTime:%d", pPlayer.dwID, szName, nDegree, nTime))
  return true
end
function DegreeCtrl:ReduceDegree(pPlayer, szName, nDegree)
  local nCurDegree, nLastAddTime = self:GetDegree(pPlayer, szName)
  if not nCurDegree or nDegree > nCurDegree then
    return false
  end
  local nCurTime = GetTime()
  if tbAddSetting[szName] then
    local nMaxDegree = self:GetMaxDegree(szName, pPlayer)
    if nCurDegree < nMaxDegree and nLastAddTime then
      nCurTime = nLastAddTime
    end
  end
  return self:SetDegree(pPlayer, szName, self:GetMaxDegree(szName, pPlayer) - nCurDegree + nDegree, nCurTime)
end
function DegreeCtrl:AddDegree(pPlayer, szName, nDegree)
  local nCurDegree, nLastAddTime = self:GetDegree(pPlayer, szName)
  local nCurTime = GetTime()
  if tbAddSetting[szName] then
    local nMaxDegree = self:GetMaxDegree(szName, pPlayer)
    if nCurDegree < nMaxDegree and nLastAddTime then
      nCurTime = nLastAddTime
    end
  end
  return self:SetDegree(pPlayer, szName, self:GetMaxDegree(szName, pPlayer) - nCurDegree - nDegree, nCurTime)
end
function DegreeCtrl:GetBuyCountInfo(szName)
  return tbBuyCountSetting[szName]
end
function DegreeCtrl:BuyCountCostPrice(pPlayer, szName, nDegree)
  local tbInfo = tbBuyCountSetting[szName]
  local szBuyDegree, szMoneyType, nMoney = unpack(tbInfo)
  if type(nMoney) == "number" then
    return szBuyDegree, szMoneyType, nMoney * nDegree, nMoney
  end
  local nHasBuy = self:GetMaxDegree(szBuyDegree, pPlayer) - self:GetDegree(pPlayer, szBuyDegree)
  local nToDegree = nHasBuy + nDegree
  local nTotalPrice = 0
  for i, v in ipairs(nMoney) do
    local nMaxCount, nPrice = unpack(v)
    if nHasBuy <= nMaxCount then
      local nBuy = math.min(nMaxCount, nToDegree) - nHasBuy
      nTotalPrice = nTotalPrice + nPrice * nBuy
      nHasBuy = nHasBuy + nBuy
      if nToDegree <= nHasBuy then
        break
      end
    end
  end
  return szBuyDegree, szMoneyType, nTotalPrice
end
function DegreeCtrl:BuyCount(pPlayer, szName, nDegree)
  if nDegree < 1 then
    return false
  end
  local tbInfo = tbBuyCountSetting[szName]
  if not tbInfo then
    return false
  end
  local szBuyDegree, szMoneyType, nCost = DegreeCtrl:BuyCountCostPrice(pPlayer, szName, nDegree)
  local nCurDegree = self:GetDegree(pPlayer, szBuyDegree)
  if not nCurDegree or nDegree > nCurDegree then
    pPlayer.CenterMsg("您今天的购买次数已经用完了")
    return false
  end
  local tbDegInfo = self.tbSetting[szName][1]
  local nLogReason2 = tbDegInfo[1] * 1000 + tbDegInfo[2]
  if szMoneyType ~= "Gold" then
    if not DegreeCtrl:ReduceDegree(pPlayer, szBuyDegree, nDegree) then
      pPlayer.CenterMsg("您今天的购买次数已经用完了")
      return false
    end
    if not pPlayer.CostMoney(szMoneyType, nCost, Env.LogWay_DegreeCtrl, nLogReason2) then
      pPlayer.CenterMsg("您的钱不足了哦")
      return false
    end
    DegreeCtrl:AddDegree(pPlayer, szName, nDegree)
    pPlayer.CallClientScript("me.BuyTimesSuccess")
    return true
  end
  local bRet = pPlayer.CostGold(nCost, Env.LogWay_DegreeCtrl, nLogReason2, function(nPlayerId, bSuccess, szBilloNo, szBuyDegree, nDegree, szName)
    local pPlayer = KPlayer.GetPlayerObjById(nPlayerId)
    if not pPlayer then
      return false, "购买次数中途, 您掉线了"
    end
    if not bSuccess then
      return false, "支付失败请稍后再试"
    end
    if not DegreeCtrl:ReduceDegree(pPlayer, szBuyDegree, nDegree) then
      return false, "您今天的购买次数已经用完了"
    end
    DegreeCtrl:AddDegree(pPlayer, szName, nDegree)
    pPlayer.CallClientScript("me.BuyTimesSuccess")
    return true
  end, szBuyDegree, nDegree, szName)
  return bRet
end
function DegreeCtrl:GetJoinCount(pPlayer, szName)
  local tbInfo = tbSetting[szName]
  if not tbInfo then
    return 999
  end
  local nGroup, nId = unpack(tbInfo[1])
  local nCostedDegree = pPlayer.GetUserValue(nGroup, nId)
  return math.max(nCostedDegree, 0)
end
